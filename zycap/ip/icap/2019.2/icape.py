#!/usr/bin/env python

"""
Generates an ICAPE interface
"""

from __future__ import print_function

from nmigen.back import verilog
from nmigen import *
from nmigen.hdl.rec import *

import argparse
import math
from jinja2 import Template

def main():
    parser = argparse.ArgumentParser(description=__doc__.strip())
    parser.add_argument('-n', '--name',   type=str, help="module name")
    parser.add_argument('-v', '--version',   type=int, default=3, help="version of ICAPE")
    parser.add_argument('-o', '--output', type=str, default='icape.v', help="output file name")

    args = parser.parse_args()

    try:
        generate(**args.__dict__)
    except IOError as ex:
        print(ex)
        exit(1)

def generate(name='icape', version=3, output=f"icape.v"):
    if version == None:
        version = 3

    if name == None:
        name = 'icape'

    icap = ICAPE(version)
    with open(output, "w") as f:
        f.writelines(["/* Generated by ZyCAP Toolflow */\n","/* DO NOT EDIT THIS FILE */\n"])
        f.write(verilog.convert(icap, name=name, ports=[
            icap.clk, 
            icap.irq_done,
            icap.rw,
            icap.err,

            icap.m_axis_tdata, 
            icap.m_axis_tready, 
            icap.m_axis_tvalid, 

            icap.s_axis_tdata, 
            icap.s_axis_tready, 
            icap.s_axis_tvalid, 
            icap.s_axis_tlast,
        ]))

class ICAPE(Elaboratable):
    """
    An interface for the Internal Configuration Access Port (ICAP).

    Parameters
    ----------
    version : int
        Sets the version of ICAPE primitive to use (determined by device architecture).

    """
    def __init__(self, version):
        self.version = version

        # Ports
        self.clk = ClockSignal()
        self.irq_done = Signal()
        self.rw = Signal()
        self.err = Signal()

        # AXIS M
        self.m_axis_tdata = Signal(unsigned(32))
        self.m_axis_tready = Signal()
        self.m_axis_tvalid = Signal()
        self.m_axis_tlast = Signal()

        # AXIS S
        self.s_axis_tdata = Signal(unsigned(32))
        self.s_axis_tready = Signal()
        self.s_axis_tvalid = Signal()
        self.s_axis_tlast = Signal()

        # self.m_axis = Record([
        #     ("tdata", unsigned(32)),
        #     ("tready", 1),
        #     ("tvalid", 1),
        #     ("tlast", 1),
        # ])
        # self.s_axis = Record([
        #     ("tdata", unsigned(32)),
        #     ("tready", 1),
        #     ("tvalid", 1),
        #     ("tlast", 1),
        # ])

    def elaborate(self, platform):
        m = Module()

        avail = Signal()
        error = Signal()

        data_in = Signal(32)
        data_out = Signal(32)

        m.d.sync += self.err.eq(error)

        # Byte Swap for ICAP Input
        m.d.comb += data_in[0:8].eq(self.s_axis_tdata[32:23:-1])
        m.d.comb += data_in[8:16].eq(self.s_axis_tdata[23:15:-1])
        m.d.comb += data_in[16:24].eq(self.s_axis_tdata[15:7:-1])
        m.d.comb += data_in[24:32].eq(self.s_axis_tdata[7::-1])

        # Byte Swap for ICAP Output
        m.d.comb += self.m_axis_tdata[0:8].eq(data_out[32:23:-1])
        m.d.comb += self.m_axis_tdata[8:16].eq(data_out[23:15:-1])
        m.d.comb += self.m_axis_tdata[16:24].eq(data_out[15:7:-1])
        m.d.comb += self.m_axis_tdata[24:32].eq(data_out[7::-1])

        with m.If(self.rw == 1):
            m.d.comb += self.s_axis_tready.eq(avail)
        with m.Elif(self.rw == 0):
            m.d.comb += self.m_axis_tvalid.eq(avail)

        # with m.If( self.s_axis_tready ):
        #     m.d.sync += self.err.eq( error )

        if self.version == 2:
            m.submodules.icap = Instance(f"ICAPE{self.version}",
                p_DEVICE_ID=0xbeefcafe,
                p_ICAP_WIDTH="X32",
                p_SIM_CFG_FILE_NAME="NONE",

                o_O  = data_out,

                i_CLK=self.clk,
                i_CSIB=~self.s_axis_tvalid,
                i_I  = data_in,
                i_RDWRB=self.rw,
            )
        elif self.version == 3:
            m.submodules.icap = Instance(f"ICAPE{self.version}",
                p_DEVICE_ID=0xdeadbeef,
                p_ICAP_AUTO_SWITCH="DISABLE",
                p_SIM_CFG_FILE_NAME="NONE",

                o_AVAIL=avail,
                o_O  = data_out,
                o_PRDONE=self.irq_done,
                o_PRERROR=error,

                i_CLK=self.clk,
                i_CSIB=~self.s_axis_tvalid,
                i_I  = data_in,
                i_RDWRB=self.rw,
            )
        else:
            return ValueError("Only ICAPE_2 or ICAPE_3 are supported.")

        return m

main()