#!/usr/bin/env python

"""
Generates an ICAPE interface
"""

from __future__ import print_function

from nmigen.back import verilog
from nmigen import *
from nmigen.hdl.rec import *

import argparse
import math
from jinja2 import Template

def main():
    parser = argparse.ArgumentParser(description=__doc__.strip())
    parser.add_argument('-n', '--name',   type=str, help="module name")
    parser.add_argument('-v', '--version',   type=int, default=3, help="version of ICAPE")
    parser.add_argument('-o', '--output', type=str, default='icape.v', help="output file name")

    args = parser.parse_args()

    try:
        generate(**args.__dict__)
    except IOError as ex:
        print(ex)
        exit(1)

def generate(name='icape', version=3, output=f"icape.v"):
    if version == None:
        version = 3

    if name == None:
        name = 'icape'

    icap = ICAPE(version)
    with open(output, "w") as f:
        f.writelines(["/* Generated by ZyCAP Toolflow */\n","/* DO NOT EDIT THIS FILE */\n"])
        f.write(verilog.convert(icap, name=name, ports=[
            icap.clk, 
            icap.irq,
            icap.rw,
            icap.err,

            icap.axis_m.tdata, 
            icap.axis_m.tready, 
            icap.axis_m.tvalid, 

            icap.axis_s.tdata, 
            icap.axis_s.tready, 
            icap.axis_s.tvalid, 
            icap.axis_s.tlast,
        ]))

class ICAPE(Elaboratable):
    """
    An interface for the Internal Configuration Access Port (ICAP).

    Parameters
    ----------
    version : int
        Sets the version of ICAPE primitive to use (determined by device architecture).

    """
    def __init__(self, version):
        self.version = version

        # Ports
        self.clk = ClockSignal()
        self.irq = Signal()
        self.rw = Signal()
        self.err = Signal()

        self.axis_m = Record([
            ("tdata", unsigned(32)),
            ("tready", 1),
            ("tvalid", 1),
            ("tlast", 1),
        ])
        self.axis_s = Record([
            ("tdata", unsigned(32)),
            ("tready", 1),
            ("tvalid", 1),
            ("tlast", 1),
        ])

    def elaborate(self, platform):
        m = Module()

        avail = Signal()
        error = Signal()
        irq = Signal()

        data_in = Signal(32)
        data_out = Signal(32)

        m.d.sync += self.err.eq(error)

        # Byte Swap for ICAP Input
        m.d.comb += data_in[0:8].eq(self.axis_s.tdata[32:23:-1])
        m.d.comb += data_in[8:16].eq(self.axis_s.tdata[23:15:-1])
        m.d.comb += data_in[16:24].eq(self.axis_s.tdata[15:7:-1])
        m.d.comb += data_in[24:32].eq(self.axis_s.tdata[7::-1])

        # Byte Swap for ICAP Output
        m.d.comb += self.axis_m.tdata[0:8].eq(data_out[32:23:-1])
        m.d.comb += self.axis_m.tdata[8:16].eq(data_out[23:15:-1])
        m.d.comb += self.axis_m.tdata[16:24].eq(data_out[15:7:-1])
        m.d.comb += self.axis_m.tdata[24:32].eq(data_out[7::-1])

        with m.If(self.rw):
            m.d.comb += self.axis_s.tready.eq(avail)
        with m.Elif(~self.rw):
            m.d.comb += self.axis_m.tvalid.eq(avail)

        with m.If( self.axis_s.tready ):
            m.d.sync += self.err.eq( error )

        if self.version == 2:
            m.submodules.icap = Instance(f"ICAPE{self.version}",
                p_DEVICE_ID=0xbeefcafe,
                p_ICAP_WIDTH="X32",
                p_SIM_CFG_FILE_NAME="NONE",

                o_O  = data_out,

                i_CLK=self.clk,
                i_CSIB=~self.axis_s.tvalid,
                i_I  = data_in,
                i_RDWRB=self.rw,
            )
        elif self.version == 3:
            m.submodules.icap = Instance(f"ICAPE{self.version}",
                p_DEVICE_ID=0xdeadbeef,
                p_ICAP_AUTO_SWITCH="DISABLED",
                p_SIM_CFG_FILE_NAME="NONE",

                o_AVAIL=avail,
                o_O  = data_out,
                o_PRDONE=irq,
                o_PRERROR=error,

                i_CLK=self.clk,
                i_CSIB=~self.axis_s.tvalid,
                i_I  = data_in,
                i_RDWRB=self.rw,
            )
        else:
            return ValueError("Only ICAPE_2 or ICAPE_3 are supported.")

        return m


# from collections import namedtuple
# import warnings

# from nmigen import *
# from nmigen.lib.cdc import ResetSynchronizer
# from nmigen.cli import main

# from nmigen import *
# from nmigen_lib.util.main import Main


# class PLL(Elaboratable):

#     """
#     Instantiate the iCE40's phase-locked loop (PLL).
#     This uses the iCE40's SB_PLL40_PAD primitive in simple feedback
#     mode.
#     The reference clock is directly connected to a package pin. To
#     allocate that pin, request the pin with dir='-'; otherwise nMigen
#     inserts an SB_IO on the pin.  E.g.,
#         clk_pin = platform.request('clk12', dir='-')
#     Because the PLL eats the external clock, that clock is not available
#     for other uses.  So you might as well have the PLL generate the
#     default 'sync' clock domain.
#     This module also has a reset synchronizer -- the domain's reset line
#     is not released until a few clocks after the PLL lock signal is
#     good.
#     """

#     def __init__(self, freq_in_mhz, freq_out_mhz, domain_name='sync'):
#         self.freq_in = freq_in_mhz
#         self.freq_out = freq_out_mhz
#         self.coeff = self._calc_freq_coefficients()
#         self.clk_pin = Signal()
#         self.domain_name = domain_name
#         self.domain = ClockDomain(domain_name)
#         self.ports = [
#             self.clk_pin,
#             self.domain.clk,
#             self.domain.rst,
#         ]

#     def _calc_freq_coefficients(self):
#         # cribbed from Icestorm's icepll.
#         f_in, f_req = self.freq_in, self.freq_out
#         assert 10 <= f_in <= 13
#         assert 16 <= f_req <= 275
#         coefficients = namedtuple('coefficients', 'divr divf divq')
#         divf_range = 128        # see comments in icepll.cc
#         best_fout = float('inf')
#         for divr in range(16):
#             pfd = f_in / (divr + 1)
#             if 10 <= pfd <= 133:
#                 for divf in range(divf_range):
#                     vco = pfd * (divf + 1)
#                     if 533 <= vco <= 1066:
#                         for divq in range(1, 7):
#                             fout = vco * 2**-divq
#                             if abs(fout - f_req) < abs(best_fout - f_req):
#                                 best_fout = fout
#                                 best = coefficients(divr, divf, divq)
#         if best_fout != f_req:
#             warnings.warn(
#                 f'PLL: requested {f_req} MHz, got {best_fout} MHz)',
#                 stacklevel=3)
#         return best

#     def elaborate(self, platform):

#         # coeff = self._calc_freq_coefficients()

#         pll_lock = Signal()
#         pll = Instance("SB_PLL40_PAD",
#             p_FEEDBACK_PATH='SIMPLE',
#             p_DIVR=self.coeff.divr,
#             p_DIVF=self.coeff.divf,
#             p_DIVQ=self.coeff.divq,
#             p_FILTER_RANGE=0b001,

#             i_PACKAGEPIN=self.clk_pin,
#             i_RESETB=Const(1),
#             i_BYPASS=Const(0),

#             o_PLLOUTGLOBAL=ClockSignal(self.domain_name),
#             o_LOCK=pll_lock)
#         rs = ResetSynchronizer(~pll_lock, domain=self.domain_name)

#         m = Module()
#         m.submodules += [pll, rs]
#         return m

# if __name__ == '__main__':
#     # pll = PLL(12, 30)
#     # main(pll, ports=pll.ports)
    
#     design = PLL(12, 30)
#     fragment = Fragment.get(design, platform=None)
#     print(verilog.convert(fragment, name='counter', ports=design.ports))
main()