#!/usr/bin/env python

"""
Generates an ICAPE interface
"""

from __future__ import print_function

from nmigen.back import verilog
from nmigen import *
from nmigen.hdl.rec import *

import argparse
import math
from jinja2 import Template

def main():
    parser = argparse.ArgumentParser(description=__doc__.strip())
    parser.add_argument('-n', '--name',   type=str, help="module name")
    parser.add_argument('-v', '--version',   type=int, default=3, help="version of ICAPE")
    parser.add_argument('-o', '--output', type=str, default='icape.v', help="output file name")

    args = parser.parse_args()

    try:
        generate(**args.__dict__)
    except IOError as ex:
        print(ex)
        exit(1)

def generate(name='icape', version=3, output=f"icape.v"):
    if version == None:
        version = 3

    if name == None:
        name = 'icape'

    icap = ICAPE(version)
    with open(output, "w") as f:
        f.writelines(["/* Generated by ZyCAP Toolflow */\n","/* DO NOT EDIT THIS FILE */\n"])
        f.write(verilog.convert(icap, name=name, ports=[
            icap.clk, 
            icap.irq,
            icap.rw,
            icap.err,

            icap.axis_m.tdata, 
            icap.axis_m.tready, 
            icap.axis_m.tvalid, 

            icap.axis_s.tdata, 
            icap.axis_s.tready, 
            icap.axis_s.tvalid, 
            icap.axis_s.tlast,
        ]))

class ICAPE(Elaboratable):
    """
    An interface for the Internal Configuration Access Port (ICAP).

    Parameters
    ----------
    version : int
        Sets the version of ICAPE primitive to use (determined by device architecture).

    """
    def __init__(self, freq):
        self.freq = freq # 50000000
        self.clk = ClockSignal()
        self.led = Signal()

    def elaborate(self, platform):
        m = Module()

        count = Signal(32)
        div_clk = Signal()

        div = ClockDomain("div_clk")
        m.domains += div

        with m.If(self.count == 50000000):
            m.d.div += self.count.eq(0)
            m.d.div += self.led.eq(~self.led)
        with m.Else():
            m.d.div += self.count.eq(self.count + 1)

        m.submodules.clkwiz = Instance("clk_wiz_0_clk_wiz",
            o_clk_out1 = div_clk,

            i_clk_in1  = self.clk,
            i_reset    = self.axis_s.tvalid,
        )

        return m

main()



# clk_wiz_0_clk_wiz inst
# (
# // Clock out ports  
# .clk_out1(clk_out1),
# // Status and control signals               
# .reset(reset), 
# .locked(locked),
# // Clock in ports
# .clk_in1(clk_in1)
# );